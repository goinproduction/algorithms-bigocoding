TIME COMPLEXITY

ARRAYLIST:
    Add: Amortized O(1)
    Remove: O(n)
    Contains: O(n)
    Size: O(1)

LINKED LIST:
    Inserting: O(1), if done at the head, O(n) if anywhere else since we have to reach that position by traveseing the linkedlist linearly.
    Deleting: O(1), if done at the head, O(n) if anywhere else since we have to reach that position by traveseing the linkedlist linearly.
    Searching: O(n)

DLINKED LIST:
    Inserting: O(1), if done at the head or tail, O(n) if anywhere else since we have to reach that position by traveseing the linkedlist linearly.
    Deleting: O(1), if done at the head or tail, O(n) if anywhere else since we have to reach that position by traveseing the linkedlist linearly.
    Searching: O(n)
STACK:
    Push: O(1)
    Pop: O(1)
    Top: O(1)
    Search (Something like lookup, as a special operation): O(n) (I guess so)

QUEUE:
    Insert: O(1)
    Remove: O(1)
    Size: O(1)
BST:
    Insert, delete and search: Average case: O(log n), Worst Case: O(n)

Red-Black Tree:
    Insert, delete and search: Average case: O(log n), Worst Case: O(log n)

Heap/PriorityQueue (min/max):
    Find Min/Find Max: O(1)
    Insert: O(log n)
    Delete Min/Delete Max: O(log n)
    Extract Min/Extract Max: O(log n)
    Lookup, Delete (if at all provided): O(n), we will have to scan all the elements as they are not ordered like BST

HashMap/Hashtable/HashSet:
    Insert/Delete: O(1) amortized
    Re-size/hash: O(n)
    Contains: O(1)